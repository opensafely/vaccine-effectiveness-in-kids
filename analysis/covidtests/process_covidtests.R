######################################

# This script:
# reads in testing data (generates dummy data if not running on real data)
# processes testing data
# sense checks the processed data
# checks that fup-params n_any and n_pos were used in the study definition were appropriate
# plots the distribution of the testing behaviour variables
# saves the data
######################################

# Preliminaries ----

## Import libraries ----
library('tidyverse')
library('lubridate')
library('arrow')
library('here')
library('glue')

## import local functions and parameters ---

source(here("analysis", "design.R"))

source(here("lib", "functions", "utility.R"))
source(here("lib", "functions", "survival.R"))

## import command-line arguments ----

args <- commandArgs(trailingOnly = TRUE)

if (length(args) == 0) {
  cohort <- "over12"
  vaxn <- 1L
} else {
  cohort <- args[[1]]
  vaxn <- args[[2]]
} 

## create output directories ----
outdir <- ghere("output", cohort,"vax{vaxn}", "covidtests")
fs::dir_create(file.path(outdir, "extract"))
fs::dir_create(file.path(outdir, "process"))
fs::dir_create(file.path(outdir, "checks"))

# import data ----

studydef_path <- file.path(outdir, "extract", "input_covidtests_{arm}.feather")
data_studydef_dummy <- bind_rows(
  # read extracted data for treated and control
  lapply(
    c("treated", "control"),
    function(arm) read_feather(glue(studydef_path))
  )
) %>%
  # because date types are not returned consistently by cohort extractor
  mutate(across(ends_with("_date"), ~ as.Date(.))) %>%
  # because of a bug in cohort extractor -- remove once fixed
  mutate(patient_id = as.integer(patient_id))

# create labels for covidtestcuts (to match the ones generated by the cuts() function)
covidtestcuts_labels <- as.character(glue("({covidtestcuts[-length(covidtestcuts)]},{covidtestcuts[-1]}]"))

# use externally created dummy data if not running in the server
# check variables are as they should be
if(Sys.getenv("OPENSAFELY_BACKEND") %in% c("", "expectations")){
  
  # generate custom dummy data
  data_custom_dummy <- local({
    
    # set seed so that dummy data results are reproducible
    set.seed(10)
    
    case_category <- c("LFT_Only"=0.4, "PCR_Only"=0.5, "LFT_WithPCR"=0.1)
    symptomatic <- c("N"=0.4, "Y"=0.6)
    
    data_tests <- read_rds(ghere("output", cohort,"vax{vaxn}", "match", "data_matched.rds")) %>%
      select(patient_id, trial_date)
    
    # add number of tests variables
    data_tests <- data_tests %>%
      bind_cols(map_dfc(
        .x = seq_along(covidtestcuts_labels)-1, #-1 because python starts at 0
        .f = ~tibble(
          !! sym(str_c("anytest_", .x, "_n")) := rpois(n=nrow(data_tests), lambda = 2),
          !! sym(str_c("postest_", .x, "_n")) := as.integer(pmax(
            !! sym(str_c("anytest_", .x, "_n")) - rpois(n=nrow(data_tests), lambda = 1),
            0
          ))
        )
      ))
        
    
    data_tests <- data_tests %>%
      mutate(
        # first anytest during the period
        anytest_1_day = if_else(
          rbernoulli(n = nrow(data_tests), p=0.3),
          NA_integer_,
          as.integer(runif(
            n=nrow(data_tests),
            -prebaselineperiods*postbaselinedays, 
            baselinedays+postbaselineperiods*postbaselinedays
          ))
        ),
        # symptom category of anytest_1_day
        anytest_1_symptomatic = if_else(
          is.na(anytest_1_day),
          NA_integer_,
          as.integer(rbernoulli(n=nrow(data_tests), p=symptomatic[["Y"]]))
          ),
        # first positive test in the period (anytest_1_day with added missingness for negative tests)
        postest_1_day = if_else(
          rbernoulli(n = nrow(data_tests), p=0.5),
          NA_integer_,
          anytest_1_day
        ),
        # first positive test in the period and ever (postest_1_day with added missingness for those that have had a positive test before the period)
        firstpostest_day = if_else(
          is.na(postest_1_day) | rbernoulli(n = nrow(data_tests), p=0.3),
          NA_integer_, 
          postest_1_day
        ),
        # type of test on firstpostest_day
        firstpostest_category = factor(
          if_else(
            is.na(firstpostest_day),
            NA_character_, 
            sample(x=names(case_category), size = nrow(data_tests), prob = unname(case_category), replace=TRUE)
          ),
          levels = names(case_category)
        )
      ) 
    
    for (i in 2:n_any) {
      
      # derive subsequent anytest_*_day and anytest_*_symptomatic
      data_tests <- data_tests %>%
        mutate(
          !! sym(glue("anytest_{i}_day")) := if_else(
            rbernoulli(n = nrow(data_tests), p=0.3),
            NA_integer_,
            !! sym(glue("anytest_{i-1}_day")) + as.integer(runif(n=nrow(data_tests), 1, 50))
          ),
          !! sym(glue("anytest_{i}_symptomatic")) := if_else(
            is.na(!! sym(glue("anytest_{i}_day"))),
            NA_integer_,
            as.integer(rbernoulli(n=nrow(data_tests), p=symptomatic[["Y"]]))
          )
        )
      
      # derive subsequent postest_*_day
      if (i <= n_pos) {
        data_tests <- data_tests %>%
          mutate(
            !! sym(glue("postest_{i}_day")) := if_else(
              rbernoulli(n = nrow(data_tests), p=0.5),
              NA_integer_,
              !! sym(glue("anytest_{i}_day"))
            )
          ) 
      }
      
    }
    
    data_tests <- data_tests %>%
      mutate(across(matches("anytest_\\d+_symptomatic"), factor, levels = c(0,1), labels = names(symptomatic))) %>%
      mutate(across(ends_with("_day"), ~ as.Date(as.character(trial_date + .)))) %>%
      rename_with(~str_replace(., "_day", "_date"), ends_with("_day")) 
    
    return(data_tests)
    
    
  })
  
  not_in_studydef <- names(data_custom_dummy)[!( names(data_custom_dummy) %in% names(data_studydef_dummy) )]
  not_in_custom  <- names(data_studydef_dummy)[!( names(data_studydef_dummy) %in% names(data_custom_dummy) )]
  
  
  if(length(not_in_custom)!=0) stop(
    paste(
      "These variables are in studydef but not in custom: ",
      paste(not_in_custom, collapse=", ")
    )
  )
  
  if(length(not_in_studydef)!=0) stop(
    paste(
      "These variables are in custom but not in studydef: ",
      paste(not_in_studydef, collapse=", ")
    )
  )
  
  # reorder columns
  data_studydef_dummy <- data_studydef_dummy[,names(data_custom_dummy)]
  
  unmatched_types <- cbind(
    map_chr(data_studydef_dummy, ~paste(class(.), collapse=", ")),
    map_chr(data_custom_dummy, ~paste(class(.), collapse=", "))
  )[ (map_chr(data_studydef_dummy, ~paste(class(.), collapse=", ")) != map_chr(data_custom_dummy, ~paste(class(.), collapse=", ")) ), ] %>%
    as.data.frame() %>% rownames_to_column()
  
  
  if(nrow(unmatched_types)>0) stop(
    #unmatched_types
    "inconsistent typing in studydef : dummy dataset\n",
    apply(unmatched_types, 1, function(row) paste(paste(row, collapse=" : "), "\n"))
  )
  
  data_extract <- data_custom_dummy 
  rm(data_studydef_dummy, data_custom_dummy)
  
} else {
  
  data_extract <- data_studydef_dummy
  rm(data_studydef_dummy)
  
}

# summarise and save data_extract
my_skim(data_extract, path = file.path(outdir, "extract", "input_treated_skim.txt"))

data_split <- local({
  
  # derive censor date and time until censoring
  data_matched <- read_rds(ghere("output", cohort,"vax{vaxn}", "match", "data_matched.rds")) %>%
    mutate(
      censor_date = pmin(
        dereg_date,
        death_date,
        study_dates$testend_date,
        trial_date - 1 + maxfup,
        controlistreated_date - 1,
        na.rm = TRUE
      ),
      tte_censor = as.integer(censor_date-(trial_date-1)),
      ind_outcome = 0
      # censor_date = trial_date + maxfup # use this to overwrite above definition until issue with `patients.minimum_of()` and date arithmetic is fixed
    ) %>%
    select(patient_id, trial_date, treated, censor_date, tte_censor) %>%
    group_by(patient_id, trial_date) %>%
    mutate(new_id = cur_group_id()) %>% 
    ungroup()
  
  # generate dataset with postbaselinecuts
  fup_split <- data_matched %>%
    select(new_id) %>%
    uncount(weights = length(postbaselinecuts)-1, .id="period_id") %>%
    mutate(fupstart_time = postbaselinecuts[period_id]) %>%
    droplevels() %>%
    select(new_id, period_id, fupstart_time) 
  
  # split time until censoring by postbaseline cuts
  data_split <-
    tmerge(
      data1 = data_matched,
      data2 = data_matched,
      id = new_id,
      tstart = 0,
      tstop = tte_censor
    ) %>%
    # add post-treatment periods
    tmerge(
      data1 = .,
      data2 = fup_split,
      id = new_id,
      period_id = tdc(fupstart_time, period_id)
    ) %>%
    mutate(
      fup_cut = cut(
        tstop, # because closed on the right
        breaks = covidtestcuts,
        right=TRUE
      )
    ) %>%
    transmute(
      patient_id, trial_date, treated, censor_date, fup_cut,
      persondays = as.integer(tstop-tstart)
    ) %>%
    as_tibble()
  
  return(data_split)
  
})

# reshape data_extract to data_anytest_long
data_anytest_long <- data_extract %>%
  # select recurring date variables
  select(patient_id, trial_date, matches(c("\\w+test_\\d+_date", "\\w+test_\\d+_symptomatic"))) %>%
  # rename to make it easier to reshape
  rename_with(
    .fn = ~str_c(str_extract(.x, "\\d+_"), str_remove(.x, "\\d+_")), 
    .cols = matches("\\w+test_\\d+_\\w+")
    ) %>%
  pivot_longer(
    cols = matches("\\d+_\\w+test_\\w+"),
    names_to = c("index", ".value"),
    names_pattern = "(.*)_(.*_.*)",
    values_drop_na = TRUE
  ) %>%
  mutate(anytest_result = if_else(is.na(postest_date), "negative", "positive")) %>%
  select(-index, -postest_date) %>%
  left_join(
    data_extract %>% select(patient_id, trial_date, starts_with("firstpostest")), 
    # joining on  "anytest_date" = "firstpostest_date" here means that firstpostest_category joined to date of individual's first ever postest
    by = c("patient_id", "trial_date", "anytest_date" = "firstpostest_date")
  ) %>%
  # join censor date
  left_join(
    data_split %>%
      distinct(patient_id, trial_date, treated, censor_date), 
    by = c("patient_id", "trial_date")
    ) %>%
  mutate(censor = if_else(anytest_date <= censor_date, FALSE, TRUE)) %>%
  # bin anytest_date
  mutate(
    anytest_cut=cut(
      as.integer(anytest_date - trial_date),
      breaks = covidtestcuts,
      right=TRUE
    )
  ) %>%
  select(-anytest_date, -censor_date) %>% # remove unused
  # remove any that are outside the time periods of interest (if this is the case for anytest_cut, it will be the case for all)
  filter(!is.na(anytest_cut)) %>%
  arrange(patient_id, trial_date, anytest_cut) 

# calculate the sum of events per period
data_anytest_sum <- data_anytest_long %>%
  # sum the number of tests per period
  group_by(patient_id, trial_date, treated, anytest_cut) %>%
  summarise(
    # sum all dates (this is just used to check value of n in study definition if correct)
    sum_anytest_uncensored=n(),  
    sum_postest_uncensored=sum(anytest_result=="positive", na.rm=TRUE),  
    # all variables below in this summarise() are derived from censored dates:
    # sum censored dates (this will be used to calculate testing rates)
    sum_anytest=sum(!censor),  
    # number of positive tests
    sum_postest=sum(anytest_result=="positive" & !censor, na.rm=TRUE),  
    # number of symtpomatic tests
    sum_symptomatic=sum(anytest_symptomatic=="Y" & !censor, na.rm = TRUE),
    # number of firstpostest
    sum_firstpostest=sum(!is.na(firstpostest_category) & !censor),
    # number of each firstpostest type
    sum_lftonly=sum(firstpostest_category=="LFT_Only" & !censor, na.rm = TRUE),
    sum_pcronly=sum(firstpostest_category=="PCR_Only" & !censor, na.rm = TRUE),
    sum_both=sum(firstpostest_category=="LFT_WithPCR" & !censor, na.rm = TRUE),
    .groups="keep"
    ) %>%
  ungroup() %>%
  # join the total number of tests per period (extracted with returning="number_of_matches_in_period" in study definition)
  left_join(
    data_extract %>%
      select(patient_id, trial_date, matches("\\w+test_\\d+_n")) %>%
      pivot_longer(
        cols = matches("\\w+test_\\d+_n"),
        names_pattern = "(.*test)_(.*)_n",
        names_to = c(".value", "fup_cut")
      ) %>%
      mutate(across(
        fup_cut, 
        ~factor(as.integer(.x)+1, # +1 because python starts at 0
                levels = seq_along(covidtestcuts_labels),
                labels = covidtestcuts_labels
        ))),
    by = c("patient_id", "trial_date", "anytest_cut" = "fup_cut")
  ) %>%
  # join data_split for persondays of follow-up per period
  left_join(
    data_split %>% select(patient_id, trial_date, treated, fup_cut, persondays),
    by = c("patient_id", "trial_date", "treated", "anytest_cut" = "fup_cut")
  ) %>%
  # label periods as pre or post baseline
  mutate(
    period = factor(if_else(
      as.character(anytest_cut) %in% covidtestcuts_labels[1:fup_params$prebaselineperiods],
      "prebaseline",
      "postbaseline"
    ), levels = c("prebaseline", "postbaseline")
    )
  ) %>%
  # fill in persondays for prebaseline periods 
  # (must be postbaselinedays, otherwise they wouldn't be eligible)
  mutate(across(
    persondays,
    ~if_else(
      period=="prebaseline",
      as.integer(postbaselinedays),
      persondays
    )))


# checks ----

# sense check
cat("-----------------")
cat("Sense checks ----\n")

cat("Check maximum counts derived from firstpostest  = 1:")
data_anytest_sum %>%
  # sum all events within each patient_id, trial_date
  group_by(patient_id, trial_date) %>%
  summarise(across(c(sum_firstpostest, sum_lftonly, sum_pcronly, sum_both), sum)) %>%
  ungroup() %>%
  # max across all patient_id, trial_date
  summarise(across(c(sum_firstpostest, sum_lftonly, sum_pcronly, sum_both), max)) 

cat("When persondays=NA (i.e. patient censored before period), check sums of censored counts are always zero:\n")
data_anytest_sum %>%
  filter(is.na(persondays)) %>%
  # group_by(anytest_cut, persondays) %>%
  summarise(across(
    c(sum_anytest, sum_postest, sum_symptomatic, sum_firstpostest, sum_lftonly, sum_pcronly, sum_both),
    list(min=min, max=max)
  )) %>%
  # ungroup() %>%
  pivot_longer(
    cols=starts_with("sum"),
    names_pattern = "sum_(.*)_(.*)",
    names_to = c("name", ".value")
    )

# check that the sums of the anytest_*_date variables match the anytest*_*_n variables
# if not, it's a flag that we need to increase n in the study definition
cat("------------------------------------------")
cat("Check `n_any` and `n_pos` appropriate ----\n")

cat ("Summarise number of tests missing per person per period when summing dates:\n")
data_anytest_sum %>%
  mutate(
    n_missing_anytest = anytest - sum_anytest_uncensored,
    n_missing_postest = postest - sum_postest_uncensored
    ) %>%
  group_by(anytest_cut) %>%
  summarise(across(
    starts_with("n_missing"), 
    list(min=min, max=max, mean=mean, median=median)
    ), .groups = "keep") %>%
  ungroup() %>%
  pivot_longer(
    cols = starts_with("n_missing"),
    names_pattern = "n_missing_(.*)_(.*)",
    names_to = c("result", ".value")
  ) %>%
  arrange(result, anytest_cut) %>%
  group_split(result) %>% as.list() 


plot_function <- function(result) {
  
  plotpath <- file.path(outdir, "checks", glue("check_n_{result}.png"))
  cat(glue("see {plotpath} for sum({result}_*_date) as a percent of {result}_*_n per period"), "\n")
  
  p <- data_anytest_sum %>%
    mutate(percent = 100*!!sym(glue("sum_{result}_uncensored"))/!!sym(result)) %>%
    ggplot(aes(x=percent, colour=period)) +
    geom_freqpoly(binwidth=1) +
    facet_wrap(~anytest_cut, scales = "free_y", nrow=2) +
    theme_bw() +
    theme(legend.position = "bottom")
  ggsave(filename = plotpath, plot = p, width = 20, height = 15, units = "cm")
  return(p)
  
}

plot_function("anytest")
plot_function("postest")

cat("------------------------------------------")
cat("Check distribution of event counts ----\n")
plotpath <- file.path(outdir, "checks", "check_n_{result}.png")
cat(glue("see {plotpath} for distribution of event counts"), "\n")
data_anytest_sum %>%
  select(-ends_with("uncensored")) %>%
  select(patient_id, trial_date, treated, anytest_cut, starts_with("sum_")) %>%
  pivot_longer(
    cols = starts_with("sum")
  ) %>%
  mutate(across(treated, factor, levels=0:1, labels = c("control", "treated"))) %>%
  mutate(across(name, 
                ~factor(
                  str_remove_all(.x, "sum_"),
                  levels = c("anytest", "symptomatic", "postest", "firstpostest", "lftonly", "pcronly", "both"))
                )) %>%
  ggplot(aes(x = value, y = ..density.., colour = treated)) +
  geom_freqpoly(binwidth = 1) +
  facet_grid(anytest_cut~name) +
  scale_color_discrete(name=NULL) +
  theme_bw() +
  theme(legend.position = "bottom")
ggsave(
  filename = file.path(outdir, "checks", glue("check_counts_dist.png")),
  width = 15, height = 20, units = "cm"
)


# save dataset ----
data_anytest_sum %>%
  filter(!is.na(persondays)) %>%
  # keep only sum_*censor
  select(-ends_with("uncensored")) %>%
  select(patient_id, trial_date, treated, anytest_cut, persondays, starts_with("sum_")) %>%
  write_rds(file.path(outdir, "process", "data_anytest_sum.rds"), compress = "gz")
